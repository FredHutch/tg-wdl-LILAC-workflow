---
title: "Unpaired Variant Consensus Workflow - three callers"
author: "Amy Paguirigan"
date: "5/17/20"
output: html_document
editor_options: 
  chunk_output_type: console
---
# Packages and Credential Management
```{r eval=FALSE, include=FALSE}
require(remotes)
remotes::install_github('FredHutch/fh.wdlR')
remotes::install_github('FredHutch/tgR')
```

## Load Packages
```{r}
library(fh.wdlR); library(tidyverse); library(aws.s3); library(tgR); library(httr); 
```

## Set Credentials (run one line)
```{r}
setCreds(tokenSet = "file", path = "~/github/cred/paguirigan.R") 
```

# Pull S3 Inventory and Annotate
```{r}
tags <- listS3Objects(bucket = "fh-pi-paguirigan-a")
annotations <- tgrAnnotate(DAG = "paguirigana")
monsterMash <- dplyr::left_join(tags, annotations)
```

# Filter Inventory for Workflow Input Data
In this workflow, the input data must be unmapped bams with quality control checks.  Also, to run the workflow you'll need the bed file for the dataset up in S3.
```{r}
unique(monsterMash$workflowOutputType); unique(monsterMash$workflowName)

unpaired <- monsterMash %>% 
  filter(workflowOutputType == "unmappedBams" | 
           ( workflowName == "PairedFastqsToUnmappedBam" & grepl("unmapped.bam", key) == T)) %>% 
  dropWhen() %>% 
  select(molecular_id, omics_sample_name, key, seq_libtype, piBucket)

unpaired <- unpaired %>% 
  mutate(bamLocation = paste("s3:/", piBucket, key, sep = "/")) %>%
  mutate(bedLocation = ifelse(
    unpaired$seq_libtype == "one", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/TruSight-One-Illumina/TruSight_One_v1.1-liftover-hg38.bed",
    ifelse(unpaired$seq_libtype == "tsm", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/TruSight-Myeloid-Illumina/trusight-myeloid-amplicon-v4-track_interval-liftOver-hg38.bed",
           ifelse(unpaired$seq_libtype == "washu", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/WASHU-AML/washU_intervals-remapped-hg38.bed",
                  ifelse(unpaired$seq_libtype == "agssex6", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/AgilentSureSelectv6-Exome/S07604514_Covered-remapped-hg38.bed",
                         ifelse(unpaired$seq_libtype == "agssex5", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/AgilentSureSelectv5-Exome/S04380110_Covered-remapped-hg38.bed",
                                ifelse(unpaired$seq_libtype == "tapestriAMLPanel", "s3://fh-ctr-public-reference-data/reagent_specific_data/sequencing_panel_bed/MissionBio-AMLPanel/2019-02-13-MissionBioAML.bed", "")))))))


preselect <- unpaired %>% filter(!is.na(bedLocation)) %>% filter(seq_libtype == "one")

```

# Analysis Workflow
## Choose a Workflow
Workflow is:  tg-wdl-HALO
Download the current master branch copy and unzip the file. 
```{r}
workflowDir <- "./tg-wdl-HALO/"
repoName <- "FredHutch/tg-wdl-HALO"

this <- httr::GET(url = paste0("https://github.com/", repoName ,"/archive/master.zip"),
    httr::authenticate(Sys.getenv("GITUSERNAME"), Sys.getenv("GITTOKEN")),
    httr::write_disk(paste0(workflowDir, "master.zip"), overwrite = TRUE))

unzip(zipfile = "./Workflows/master.zip",
      exdir = "./Workflows/")
file.remove("./Workflows/master.zip")

list.files(path = workflowDir)

```

## Make a Manifest

```{r}
manifest <- preselect %>% select(omics_sample_name, bamLocation, bedLocation, molecular_id)
manifest <- manifest[1:4,]
```


## Name and Ship Batch File
```{r}
batchFileName <- paste0("cromwell-manifests/", repoName, "/", format(Sys.Date(), "%Y-%m-%d-"), "HALOValidation.tsv")
paste0("s3://fh-pi-paguirigan-a-genomicsrepo/", batchFileName)
s3write_using(manifest,
              FUN = write.table, quote = F, row.names = F, sep = "\t",
              object = batchFileName,
              bucket = "fh-pi-paguirigan-a-genomicsrepo")
thisManifest <- "cromwell-manifests/FredHutch/tg-wdl-unpairedVariantCaller/2020-03-09-HALOValidation.tsv"
```

# Cromwell Environment

## Create Cromwell Server
Create a Cromwell server on Gizmo or interact with a specific Cromwell server.  
```{r}
cromwellCreate(FredHutchId = "apaguiri", port = "1981",
        pathToServerLogs =
          "~/cromwell/tgr/server-logs/frank-%A.txt",
        pathToServerScript = 
          "~/cromwell/tgr/beAllEndAll.sh",
        pathToParams = 
          "~/cromwell/tgr/allTheParams.sh")
```

## Set Cromwell Environment 
```{r}
setCromwellURL(FredHutchId = "apaguiri", jobId = "45939968", port = "1981") 
Sys.getenv("CROMWELLURL")
Sys.setenv("CROMWELLURL" = "http://...")
```

## Validate and Submit Job
### AWS workflow
```{r}
list.files(path = workflowDir)
womtoolValidate(paste0(workflowDir, "unpaired-trio.wdl"))

thisJob <- cromwellSubmitBatch(
  WDL = paste0(workflowDir, "unpaired-trio.wdl"),
  Batch = paste0(workflowDir, "unpaired-trio-batch.json"),
  Params = paste0(workflowDir, "unpaired-trio-parameters.json"),
  Options = paste0(workflowDir, "noNewCalls-callcachingOn.json"),
  Labels = data.frame("workflowType" = "haloValidation"))

thisOne <- thisJob$id; thisOne
```

# Monitor Running Jobs

## Attempts
Jobs of interest
```{r}
thisOne <- "40b716cd-e568-4f76-8e9a-ef720e99894f"  # in AWS
thisOne <- "878ea8f5-48b4-4141-829a-0431641e8924" # trio test on gizmo
jobs <- cromwellJobs()
```

## Workflow level metadata
```{r}
w <- cromwellWorkflow(thisOne); w$status
WTF <- cromwellGlob(thisOne); WTF[["failures"]]
cromwellTiming(thisOne)
```

## Call level metadata 
```{r}
c <- cromwellCall(thisOne); c %>% group_by(executionStatus, callName) %>% summarize(status = n())
ca <- cromwellCache(thisOne); ca %>% group_by(callCaching.hit, callName) %>% summarize(hits = n())

butWhy <- left_join(cromwellCall(thisOne) %>% mutate_all(as.character), 
                    cromwellCache(thisOne) %>% mutate_all(as.character)); butWhy %>% group_by(callName, executionStatus, callCaching.hit) %>% summarize(hits = n()) %>% arrange(desc(executionStatus))
```

## Failure metadata and abort
```{r}
f <- cromwellFailures(thisOne); f
#abort <- cromwellAbort(thisOne) # Careful with this
```


# Output Processing
```{r}
out <- cromwellOutputs(thisOne) 
batchFile <- s3read_using(FUN = read.delim, stringsAsFactors = F,
                           object = thisManifest,
                           bucket = "fh-pi-paguirigan-a-genomicsrepo")
batchFile$shardIndex <- as.character(seq(from = 0, to = nrow(batchFile)-1, by = 1))
annotatedOutputs <- inner_join(batchFile, out, by = c("shardIndex")) # if no molecular_id
```

